----------------------------------------------------------------------------
-- Generated by gen_tb.py
-- File created: Tue Feb 16 16:55:48 2021
--
----------------------------------------------------------------------------

library IEEE;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_textio.all;
use ieee.numeric_std.all;
use std.textio.all;

use work.sim_package.all;

entity sparseDemoDS_tb is
end entity sparseDemoDS_tb;

architecture behav of sparseDemoDS_tb is
    -- Constants
    constant HALF_CLK_PERIOD : TIME := 2.00 ns;
    constant TRANSACTION_NUM : INTEGER := 1;
    
    -- global signals
    signal tb_clk : std_logic := '0';
    signal tb_rst : std_logic := '0';
    signal tb_start_valid : std_logic := '0';
    signal tb_start_ready : std_logic;

    -- ds 2-port memory A_ptr
    signal A_ptr_dsmem_ce0 : std_logic;
    signal A_ptr_dsmem_we0 : std_logic;
    signal A_ptr_dsmem_din0 : std_logic_vector (32-1 downto 0);
    signal A_ptr_dsmem_dout0 : std_logic_vector (32-1 downto 0);
    signal A_ptr_dsmem_address0 : std_logic_vector (32-1 downto 0);

    signal A_ptr_dsmem_ce1 : std_logic;
    signal A_ptr_dsmem_we1 : std_logic;
    signal A_ptr_dsmem_din1 : std_logic_vector (32-1 downto 0);
    signal A_ptr_dsmem_dout1 : std_logic_vector (32-1 downto 0);
    signal A_ptr_dsmem_address1 : std_logic_vector (32-1 downto 0);

    -- ds 2-port memory A_id
    signal A_id_dsmem_ce0 : std_logic;
    signal A_id_dsmem_we0 : std_logic;
    signal A_id_dsmem_din0 : std_logic_vector (32-1 downto 0);
    signal A_id_dsmem_dout0 : std_logic_vector (32-1 downto 0);
    signal A_id_dsmem_address0 : std_logic_vector (32-1 downto 0);

    signal A_id_dsmem_ce1 : std_logic;
    signal A_id_dsmem_we1 : std_logic;
    signal A_id_dsmem_din1 : std_logic_vector (32-1 downto 0);
    signal A_id_dsmem_dout1 : std_logic_vector (32-1 downto 0);
    signal A_id_dsmem_address1 : std_logic_vector (32-1 downto 0);

    -- ds 2-port memory A_val
    signal A_val_dsmem_ce0 : std_logic;
    signal A_val_dsmem_we0 : std_logic;
    signal A_val_dsmem_din0 : std_logic_vector (32-1 downto 0);
    signal A_val_dsmem_dout0 : std_logic_vector (32-1 downto 0);
    signal A_val_dsmem_address0 : std_logic_vector (32-1 downto 0);

    signal A_val_dsmem_ce1 : std_logic;
    signal A_val_dsmem_we1 : std_logic;
    signal A_val_dsmem_din1 : std_logic_vector (32-1 downto 0);
    signal A_val_dsmem_dout1 : std_logic_vector (32-1 downto 0);
    signal A_val_dsmem_address1 : std_logic_vector (32-1 downto 0);

    -- ds 2-port memory B_ptr
    signal B_ptr_dsmem_ce0 : std_logic;
    signal B_ptr_dsmem_we0 : std_logic;
    signal B_ptr_dsmem_din0 : std_logic_vector (32-1 downto 0);
    signal B_ptr_dsmem_dout0 : std_logic_vector (32-1 downto 0);
    signal B_ptr_dsmem_address0 : std_logic_vector (32-1 downto 0);

    signal B_ptr_dsmem_ce1 : std_logic;
    signal B_ptr_dsmem_we1 : std_logic;
    signal B_ptr_dsmem_din1 : std_logic_vector (32-1 downto 0);
    signal B_ptr_dsmem_dout1 : std_logic_vector (32-1 downto 0);
    signal B_ptr_dsmem_address1 : std_logic_vector (32-1 downto 0);

    -- ds 2-port memory B_id
    signal B_id_dsmem_ce0 : std_logic;
    signal B_id_dsmem_we0 : std_logic;
    signal B_id_dsmem_din0 : std_logic_vector (32-1 downto 0);
    signal B_id_dsmem_dout0 : std_logic_vector (32-1 downto 0);
    signal B_id_dsmem_address0 : std_logic_vector (32-1 downto 0);

    signal B_id_dsmem_ce1 : std_logic;
    signal B_id_dsmem_we1 : std_logic;
    signal B_id_dsmem_din1 : std_logic_vector (32-1 downto 0);
    signal B_id_dsmem_dout1 : std_logic_vector (32-1 downto 0);
    signal B_id_dsmem_address1 : std_logic_vector (32-1 downto 0);

    -- ds 2-port memory B_val
    signal B_val_dsmem_ce0 : std_logic;
    signal B_val_dsmem_we0 : std_logic;
    signal B_val_dsmem_din0 : std_logic_vector (32-1 downto 0);
    signal B_val_dsmem_dout0 : std_logic_vector (32-1 downto 0);
    signal B_val_dsmem_address0 : std_logic_vector (32-1 downto 0);

    signal B_val_dsmem_ce1 : std_logic;
    signal B_val_dsmem_we1 : std_logic;
    signal B_val_dsmem_din1 : std_logic_vector (32-1 downto 0);
    signal B_val_dsmem_dout1 : std_logic_vector (32-1 downto 0);
    signal B_val_dsmem_address1 : std_logic_vector (32-1 downto 0);

    -- ds 2-port memory C
    signal C_dsmem_ce0 : std_logic;
    signal C_dsmem_we0 : std_logic;
    signal C_dsmem_din0 : std_logic_vector (32-1 downto 0);
    signal C_dsmem_dout0 : std_logic_vector (32-1 downto 0);
    signal C_dsmem_address0 : std_logic_vector (32-1 downto 0);

    signal C_dsmem_ce1 : std_logic;
    signal C_dsmem_we1 : std_logic;
    signal C_dsmem_din1 : std_logic_vector (32-1 downto 0);
    signal C_dsmem_dout1 : std_logic_vector (32-1 downto 0);
    signal C_dsmem_address1 : std_logic_vector (32-1 downto 0);

    -- ds scalar argument end
    signal end_arg_we0 : std_logic;
    signal end_arg_din0 : std_logic_vector (1-1 downto 0);

    signal tb_temp_idle : std_logic := '1';
    shared variable transaction_idx : INTEGER := 0;

begin

duv: entity work.sparseDemoDS
    port map (
        clk => tb_clk,
        rst => tb_rst,
        A_ptr_ce0 => A_ptr_dsmem_ce0,
        A_ptr_din0 => A_ptr_dsmem_dout0,
        A_ptr_address0 => A_ptr_dsmem_address0,
        A_ptr_we0 => A_ptr_dsmem_we0,
        A_ptr_dout0 => A_ptr_dsmem_din0,

        A_ptr_ce1 => A_ptr_dsmem_ce1,
        A_ptr_din1 => A_ptr_dsmem_dout1,
        A_ptr_address1 => A_ptr_dsmem_address1,
        A_ptr_we1 => A_ptr_dsmem_we1,
        A_ptr_dout1 => A_ptr_dsmem_din1,

        A_id_ce0 => A_id_dsmem_ce0,
        A_id_din0 => A_id_dsmem_dout0,
        A_id_address0 => A_id_dsmem_address0,
        A_id_we0 => A_id_dsmem_we0,
        A_id_dout0 => A_id_dsmem_din0,

        A_id_ce1 => A_id_dsmem_ce1,
        A_id_din1 => A_id_dsmem_dout1,
        A_id_address1 => A_id_dsmem_address1,
        A_id_we1 => A_id_dsmem_we1,
        A_id_dout1 => A_id_dsmem_din1,

        A_val_ce0 => A_val_dsmem_ce0,
        A_val_din0 => A_val_dsmem_dout0,
        A_val_address0 => A_val_dsmem_address0,
        A_val_we0 => A_val_dsmem_we0,
        A_val_dout0 => A_val_dsmem_din0,

        A_val_ce1 => A_val_dsmem_ce1,
        A_val_din1 => A_val_dsmem_dout1,
        A_val_address1 => A_val_dsmem_address1,
        A_val_we1 => A_val_dsmem_we1,
        A_val_dout1 => A_val_dsmem_din1,

        B_ptr_ce0 => B_ptr_dsmem_ce0,
        B_ptr_din0 => B_ptr_dsmem_dout0,
        B_ptr_address0 => B_ptr_dsmem_address0,
        B_ptr_we0 => B_ptr_dsmem_we0,
        B_ptr_dout0 => B_ptr_dsmem_din0,

        B_ptr_ce1 => B_ptr_dsmem_ce1,
        B_ptr_din1 => B_ptr_dsmem_dout1,
        B_ptr_address1 => B_ptr_dsmem_address1,
        B_ptr_we1 => B_ptr_dsmem_we1,
        B_ptr_dout1 => B_ptr_dsmem_din1,

        B_id_ce0 => B_id_dsmem_ce0,
        B_id_din0 => B_id_dsmem_dout0,
        B_id_address0 => B_id_dsmem_address0,
        B_id_we0 => B_id_dsmem_we0,
        B_id_dout0 => B_id_dsmem_din0,

        B_id_ce1 => B_id_dsmem_ce1,
        B_id_din1 => B_id_dsmem_dout1,
        B_id_address1 => B_id_dsmem_address1,
        B_id_we1 => B_id_dsmem_we1,
        B_id_dout1 => B_id_dsmem_din1,

        B_val_ce0 => B_val_dsmem_ce0,
        B_val_din0 => B_val_dsmem_dout0,
        B_val_address0 => B_val_dsmem_address0,
        B_val_we0 => B_val_dsmem_we0,
        B_val_dout0 => B_val_dsmem_din0,

        B_val_ce1 => B_val_dsmem_ce1,
        B_val_din1 => B_val_dsmem_dout1,
        B_val_address1 => B_val_dsmem_address1,
        B_val_we1 => B_val_dsmem_we1,
        B_val_dout1 => B_val_dsmem_din1,

        C_ce0 => C_dsmem_ce0,
        C_din0 => C_dsmem_dout0,
        C_address0 => C_dsmem_address0,
        C_we0 => C_dsmem_we0,
        C_dout0 => C_dsmem_din0,

        C_ce1 => C_dsmem_ce1,
        C_din1 => C_dsmem_dout1,
        C_address1 => C_dsmem_address1,
        C_we1 => C_dsmem_we1,
        C_dout1 => C_dsmem_din1,

        end_out => end_arg_din0,
        end_valid => end_arg_we0,
        end_ready => '1',

        start_in => (others => '0'),
        start_ready => tb_start_ready,
        start_valid => tb_start_valid
    );
    
mem_inst_A_ptr: entity work.two_port_RAM
    generic map (
        TV_IN => "vectors/A_ptr_vhdl_in.dat",
        TV_OUT => "",
        DEPTH => 101,
        DATA_WIDTH => 32,
        ADDR_WIDTH => 32
    )
    port map (
        ce0 => A_ptr_dsmem_ce0,
        we0 => A_ptr_dsmem_we0,
        mem_din0 => A_ptr_dsmem_din0,
        mem_dout0 => A_ptr_dsmem_dout0,
        address0 => A_ptr_dsmem_address0,

        ce1 => A_ptr_dsmem_ce1,
        we1 => A_ptr_dsmem_we1,
        mem_din1 => A_ptr_dsmem_din1,
        mem_dout1 => A_ptr_dsmem_dout1,
        address1 => A_ptr_dsmem_address1,

        clk => tb_clk,
        rst => tb_rst,
        done => tb_temp_idle
    );

mem_inst_A_id: entity work.two_port_RAM
    generic map (
        TV_IN => "vectors/A_id_vhdl_in.dat",
        TV_OUT => "",
        DEPTH => 1022,
        DATA_WIDTH => 32,
        ADDR_WIDTH => 32
    )
    port map (
        ce0 => A_id_dsmem_ce0,
        we0 => A_id_dsmem_we0,
        mem_din0 => A_id_dsmem_din0,
        mem_dout0 => A_id_dsmem_dout0,
        address0 => A_id_dsmem_address0,

        ce1 => A_id_dsmem_ce1,
        we1 => A_id_dsmem_we1,
        mem_din1 => A_id_dsmem_din1,
        mem_dout1 => A_id_dsmem_dout1,
        address1 => A_id_dsmem_address1,

        clk => tb_clk,
        rst => tb_rst,
        done => tb_temp_idle
    );

mem_inst_A_val: entity work.two_port_RAM
    generic map (
        TV_IN => "vectors/A_val_vhdl_in.dat",
        TV_OUT => "",
        DEPTH => 1022,
        DATA_WIDTH => 32,
        ADDR_WIDTH => 32
    )
    port map (
        ce0 => A_val_dsmem_ce0,
        we0 => A_val_dsmem_we0,
        mem_din0 => A_val_dsmem_din0,
        mem_dout0 => A_val_dsmem_dout0,
        address0 => A_val_dsmem_address0,

        ce1 => A_val_dsmem_ce1,
        we1 => A_val_dsmem_we1,
        mem_din1 => A_val_dsmem_din1,
        mem_dout1 => A_val_dsmem_dout1,
        address1 => A_val_dsmem_address1,

        clk => tb_clk,
        rst => tb_rst,
        done => tb_temp_idle
    );

mem_inst_B_ptr: entity work.two_port_RAM
    generic map (
        TV_IN => "vectors/B_ptr_vhdl_in.dat",
        TV_OUT => "",
        DEPTH => 101,
        DATA_WIDTH => 32,
        ADDR_WIDTH => 32
    )
    port map (
        ce0 => B_ptr_dsmem_ce0,
        we0 => B_ptr_dsmem_we0,
        mem_din0 => B_ptr_dsmem_din0,
        mem_dout0 => B_ptr_dsmem_dout0,
        address0 => B_ptr_dsmem_address0,

        ce1 => B_ptr_dsmem_ce1,
        we1 => B_ptr_dsmem_we1,
        mem_din1 => B_ptr_dsmem_din1,
        mem_dout1 => B_ptr_dsmem_dout1,
        address1 => B_ptr_dsmem_address1,

        clk => tb_clk,
        rst => tb_rst,
        done => tb_temp_idle
    );

mem_inst_B_id: entity work.two_port_RAM
    generic map (
        TV_IN => "vectors/B_id_vhdl_in.dat",
        TV_OUT => "",
        DEPTH => 1101,
        DATA_WIDTH => 32,
        ADDR_WIDTH => 32
    )
    port map (
        ce0 => B_id_dsmem_ce0,
        we0 => B_id_dsmem_we0,
        mem_din0 => B_id_dsmem_din0,
        mem_dout0 => B_id_dsmem_dout0,
        address0 => B_id_dsmem_address0,

        ce1 => B_id_dsmem_ce1,
        we1 => B_id_dsmem_we1,
        mem_din1 => B_id_dsmem_din1,
        mem_dout1 => B_id_dsmem_dout1,
        address1 => B_id_dsmem_address1,

        clk => tb_clk,
        rst => tb_rst,
        done => tb_temp_idle
    );

mem_inst_B_val: entity work.two_port_RAM
    generic map (
        TV_IN => "vectors/B_val_vhdl_in.dat",
        TV_OUT => "",
        DEPTH => 1101,
        DATA_WIDTH => 32,
        ADDR_WIDTH => 32
    )
    port map (
        ce0 => B_val_dsmem_ce0,
        we0 => B_val_dsmem_we0,
        mem_din0 => B_val_dsmem_din0,
        mem_dout0 => B_val_dsmem_dout0,
        address0 => B_val_dsmem_address0,

        ce1 => B_val_dsmem_ce1,
        we1 => B_val_dsmem_we1,
        mem_din1 => B_val_dsmem_din1,
        mem_dout1 => B_val_dsmem_dout1,
        address1 => B_val_dsmem_address1,

        clk => tb_clk,
        rst => tb_rst,
        done => tb_temp_idle
    );

mem_inst_C: entity work.two_port_RAM
    generic map (
        TV_IN => "",
        TV_OUT => "vectors/C_vhdl_out.dat",
        DEPTH => 10000,
        DATA_WIDTH => 32,
        ADDR_WIDTH => 32
    )
    port map (
        ce0 => C_dsmem_ce0,
        we0 => C_dsmem_we0,
        mem_din0 => C_dsmem_din0,
        mem_dout0 => C_dsmem_dout0,
        address0 => C_dsmem_address0,

        ce1 => C_dsmem_ce1,
        we1 => C_dsmem_we1,
        mem_din1 => C_dsmem_din1,
        mem_dout1 => C_dsmem_dout1,
        address1 => C_dsmem_address1,

        clk => tb_clk,
        rst => tb_rst,
        done => tb_temp_idle
    );

----------------------------------------------------------------------------
-- Write "[[[runtime]]]" and "[[[/runtime]]]" for output transactor
write_C_transactor_end_runtime_proc : process
	file fp             : TEXT;
	variable fstatus    : FILE_OPEN_STATUS;
	variable token_line : LINE;

begin
	file_open(fstatus, fp, "vectors/C_vhdl_out.dat", WRITE_MODE);
	if (fstatus /= OPEN_OK) then
		assert false report "Open file " & "vectors/C_vhdl_out.dat" & " failed!!!" severity note;
		assert false report "ERROR: Simulation using HLS TB failed." severity failure;
	end if;
	write(token_line, string'("[[[runtime]]]"));
	writeline(fp, token_line);
	file_close(fp);
	while transaction_idx /= TRANSACTION_NUM loop
		wait until tb_clk'event and tb_clk = '1';
	end loop;
	wait until tb_clk'event and tb_clk = '1';
	wait until tb_clk'event and tb_clk = '1';
	file_open(fstatus, fp, "vectors/C_vhdl_out.dat", APPEND_MODE);
	if (fstatus /= OPEN_OK) then
		assert false report "Open file " & "vectors/C_vhdl_out.dat" & " failed!!!" severity note;
		assert false report "ERROR: Simulation using HLS TB failed." severity failure;
	end if;
	write(token_line, string'("[[[/runtime]]]"));
	writeline(fp, token_line);
	file_close(fp);
	wait;
end process;

-- instance for end omitted

----------------------------------------------------------------------------
generate_sim_done_proc : process
begin
	while (transaction_idx /= TRANSACTION_NUM) loop
		wait until tb_clk'event and tb_clk = '1';
	end loop;
	wait until tb_clk'event and tb_clk = '1';
	wait until tb_clk'event and tb_clk = '1';
	wait until tb_clk'event and tb_clk = '1';
	assert false report "simulation done!" severity note;
	assert false report "NORMAL EXIT (note: failure is to force the simulator to stop)" severity failure;
	wait;
end process;

----------------------------------------------------------------------------
gen_clock_proc : process
begin
	tb_clk <= '0';
	while (true) loop
		wait for HALF_CLK_PERIOD;
		tb_clk <= not tb_clk;
	end loop;
	wait;
end process;

----------------------------------------------------------------------------
gen_reset_proc : process
begin
	tb_rst <= '1';
	wait for 10 ns;
	tb_rst <= '0';
	wait;
end process;

----------------------------------------------------------------------------
generate_idle_signal: process(tb_clk,tb_rst)
begin
   if (tb_rst = '1') then
       tb_temp_idle <= '1';
   elsif rising_edge(tb_clk) then
       tb_temp_idle <= tb_temp_idle;
       if (tb_start_valid = '1') then
           tb_temp_idle <= '0';
       elsif(end_arg_we0 = '1') then
           tb_temp_idle <= '1';
       end if;
   end if;
end process generate_idle_signal;

----------------------------------------------------------------------------
generate_start_signal : process(tb_clk, tb_rst)
begin
   if (tb_rst = '1') then
       tb_start_valid <= '0';
   elsif rising_edge(tb_clk) then
       if (tb_temp_idle = '1' and tb_start_ready = '1' and tb_start_valid = '0') then
           tb_start_valid <= '1';
       else
           tb_start_valid <= '0';
       end if;
   end if;
end process generate_start_signal;

----------------------------------------------------------------------------
transaction_increment : process
begin
	wait until tb_rst = '0';
	while (tb_temp_idle /= '1') loop
		wait until tb_clk'event and tb_clk = '1';
	end loop;
	wait until tb_temp_idle = '0';

	while (true) loop
		while (tb_temp_idle /= '1') loop
			wait until tb_clk'event and tb_clk = '1';
		end loop;
		transaction_idx := transaction_idx + 1;
		wait until tb_temp_idle = '0';
	end loop;
end process;

end architecture behav;

